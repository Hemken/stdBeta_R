<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Doug Hemken" />


<title>stdBeta</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">stdBeta</h1>
<h4 class="author"><em>Doug Hemken</em></h4>
<h4 class="date"><em>July 2017</em></h4>



<div id="do-we-really-need-another-function-that-standardizes-coefficients" class="section level2">
<h2>Do we really need another function that standardizes coefficients?</h2>
<p>There are several R functions out there that will return 'standardized coefficients' of one sort or another. My chief complaint with them all is that they are difficult to interpret when the model includes interaction terms (or polynomial terms, for that matter).</p>
<p>Other package::functions that return standardized coefficients:</p>
<ul>
<li>QuantPsyc::lm.beta - standardizes the model matrix terms, including factors. Returns a vector of coefficients. Breaks on interaction terms.</li>
<li>lm.beta::lm.beta - returns an object of class “lm.beta”, an augmented “lm” object. Standardizes everything in the model matrix. Same approach as QuantPsyc::lm.beta, but with a different return object.</li>
<li>lsr::standardCoefs - returns a matrix of unstandardized and standardized coefficients. Standardizes the model matrix terms, including factors. Again, same approach as QuantPsyc::lm.beta.</li>
<li>arm::standardize - standardizes model frame, scales by 2 sds rather than 1, y optional, various factor options, options to exclude some vars, returns an “lm” object</li>
</ul>
</div>
<div id="what-are-standardized-coefficients" class="section level2">
<h2>What are 'Standardized Coefficients'?</h2>
<p>Standardized coefficients are usually described as the coefficients estimated for a model when all of the variables have been standardized. There are some variations on this basic idea, but they all begin by first - in principle - standardizing the variables.</p>
<p>I stipulate &quot;in principle&quot; because <em>in some cases</em> you do not actually have to transform your data before estimating a model. Where your model consists of only first-order, continuous variables, all you need are the standard deviations of each of your variables to calculate standardized coefficients from the unstandardized coefficients (coefficients in your data's original units).</p>
<p>The shortcut formula for transforming coefficients, usually taught in introductory regression courses, is <span class="math display">\[\beta = \sigma_x/\sigma_y \times b\]</span>, where <span class="math inline">\(b\)</span> is an unstandardized coefficient, <span class="math inline">\(\sigma_x\)</span> is the standard deviation of the independent variable in question, and <span class="math inline">\(\sigma_y\)</span> is the standard deviation of the dependent variable.</p>
<p>In quite a bit of statistical software - SAS, Stata, SPSS, and the first three R functions listed above - this formula is blindly applied to models with higher order terms as well, that is, with interaction and polynomial terms. While these coefficients are useful for many purposes, they are <strong><em>not</em></strong> consistent with the basic idea of standardized coefficients, because they are not the coefficients one would estimate were the data transformed first. Just what they do represent is convoluted.</p>
</div>
<div id="a-demonstration" class="section level2">
<h2>A Demonstration</h2>
<p>Let's start with R's common <code>mtcars</code> data, and estimate a model where these functions fail.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># First, calculate by &quot;hand&quot;</span>
zmpg &lt;-<span class="st"> </span><span class="kw">scale</span>(mtcars$mpg)
zdisp &lt;-<span class="st"> </span><span class="kw">scale</span>(mtcars$disp)
zwt &lt;-<span class="st"> </span><span class="kw">scale</span>(mtcars$wt)
<span class="kw">coefficients</span>(<span class="kw">lm</span>(zmpg ~<span class="st"> </span>zdisp*zwt))</code></pre></div>
<pre><code>## (Intercept)       zdisp         zwt   zdisp:zwt 
##  -0.2026064  -0.3845259  -0.6161045   0.2355257</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Now, fit an unstandardized model</span>
fit &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg ~<span class="st"> </span>disp*wt, mtcars)

<span class="co"># And apply the available functions</span>
QuantPsyc::<span class="kw">lm.beta</span>(fit) <span class="co"># warning given, wrong results</span></code></pre></div>
<pre><code>## Warning in b * sx: longer object length is not a multiple of shorter object
## length</code></pre>
<pre><code>##       disp         wt    disp:wt 
## -1.1589542 -1.0545547  0.2407113</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lm.beta::<span class="kw">lm.beta</span>(fit)</code></pre></div>
<pre><code>## 
## Call:
## lm(formula = mpg ~ disp * wt, data = mtcars)
## 
## Standardized Coefficients::
## (Intercept)        disp          wt     disp:wt 
##    0.000000   -1.158954   -1.054555    1.296692</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lsr::<span class="kw">standardCoefs</span>(fit) <span class="co"># agrees with lm.beta::lm.beta, but no intercept</span></code></pre></div>
<pre><code>##                   b      beta
## disp    -0.05635816 -1.158954
## wt      -6.49567966 -1.054555
## disp:wt  0.01170542  1.296692</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">arm::<span class="kw">standardize</span>(fit, <span class="dt">standardize.y=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## 
## Call:
## lm(formula = z.mpg ~ z.disp * z.wt, data = mtcars)
## 
## Coefficients:
## (Intercept)       z.disp         z.wt  z.disp:z.wt  
##     -0.1013      -0.3845      -0.6161       0.4711</code></pre>
<p>The <code>QuantPsyc</code> function uses the classic formula, but is implemented in a way that produces a warning with higher order terms. The <code>lm.beta</code> and <code>lsr</code> functions also apply the classic shortcut formula, which is at odds with the concept. The <code>arm</code> function insists on scaling by 2 standard deviations, an alternative concept.</p>
<p>So none of these really returns the coefficients we want.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stdBeta::<span class="kw">stdBeta</span>(fit)</code></pre></div>
<pre><code>## 
## Call:
## lm(formula = mpg ~ disp * wt, data = stddata)
## 
## Coefficients:
## (Intercept)         disp           wt      disp:wt  
##     -0.2026      -0.3845      -0.6161       0.2355</code></pre>
<p>This gives us the coefficients we would gotten 'by hand'.</p>
</div>
<div id="polynomial-regression" class="section level2">
<h2>Polynomial Regression</h2>
<p>R's formula specification does not allow polynomial terms to be formed as tensor products like other statistical software, which leaves three commonly used methods for specifying polynomial regressions. The first is to &quot;inhibit&quot; interpretation of the exponentiation operator.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coefficients</span>(<span class="kw">lm</span>(zmpg ~<span class="st"> </span>zwt +<span class="st"> </span><span class="kw">I</span>(zwt^<span class="dv">2</span>))) <span class="co"># by &quot;hand&quot;</span></code></pre></div>
<pre><code>## (Intercept)         zwt    I(zwt^2) 
##  -0.1802135  -0.9489152   0.1860268</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fitsq &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg ~<span class="st"> </span>wt +<span class="st"> </span><span class="kw">I</span>(wt^<span class="dv">2</span>), mtcars)
stdBeta::<span class="kw">stdBeta</span>(fitsq)</code></pre></div>
<pre><code>## 
## Call:
## lm(formula = mpg ~ wt + I(wt^2), data = stddata)
## 
## Coefficients:
## (Intercept)           wt      I(wt^2)  
##     -0.1802      -0.9489       0.1860</code></pre>
<p>The second method would be to use the <code>poly</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coefficients</span>(<span class="kw">lm</span>(zmpg ~<span class="st"> </span>zwt +<span class="st"> </span><span class="kw">I</span>(zwt^<span class="dv">2</span>))) <span class="co"># by &quot;hand&quot;</span></code></pre></div>
<pre><code>## (Intercept)         zwt    I(zwt^2) 
##  -0.1802135  -0.9489152   0.1860268</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fitpoly &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg ~<span class="st"> </span><span class="kw">poly</span>(wt,<span class="dv">2</span>,<span class="dt">raw=</span><span class="ot">TRUE</span>), <span class="dt">data=</span>mtcars)
stdBeta::<span class="kw">stdBeta</span>(fitpoly)</code></pre></div>
<pre><code>## 
## Call:
## lm(formula = mpg ~ poly(wt, 2, raw = TRUE), data = stddata)
## 
## Coefficients:
##              (Intercept)  poly(wt, 2, raw = TRUE)1  
##                  -0.1802                   -0.9489  
## poly(wt, 2, raw = TRUE)2  
##                   0.1860</code></pre>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
